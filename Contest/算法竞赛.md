# 竞赛提示

每行输出均应以回车符结束，包括最后一行。除非特别说明，每行的行首不应有空格，但行末通常可以有多余空格。另外，输出的每两个数或者字符串之间应以单个空格隔开。

尽量用const关键字声明常数

可以通过手工模拟的方法理解程序的执行方式，重点在于记录每条语句执行之后各个变量的值

Keep It Simple and Stupid，KISS

算法竞赛是在比谁能更好地解决问题，而不是在比谁写的程序看上去更高级

算法竞赛的目标是编程对任意输入均得到正确的结果，而不仅是样例数据。

适当在程序中编写注释不仅能让其他用户更快地搞懂你的程序，还能帮你自己理清思路

在学习编程时，“明知故犯”是有益的：起码你知道了错误时的现象。这样，当真的不小心犯错时，可以通过现象猜测到可能的原因。

不要忘记测试。一个看上去正确的程序可能隐含错误。

在当前流行的竞赛平台中，int都是32位整数，范围是-2147483648～2147483647

循环结构程序设计中最常见的两个问题：算术运算溢出和程序效率低下

详细阅读比赛规定，并严格遵守。例如，输入输出文件名和程序名往往都有着严格规定，不要弄错大小写，不要拼错文件名，不要使用绝对路径或相对路径

```c
#ifdef LOCAL //在本机测试时使用重定向方式读写文件
freopen("data.in", "r", stdin);
freopen("data.out", "w", stdout);
#endif
```

在算法竞赛中，有经验的选手往往会使用条件编译指令并且将重要的测试语句注释掉而非删除

```c
/* 程序2-10 数据统计（重定向版） */
#define LOCAL
#include<stdio.h>
#define INF 1000000000
int main()
{
#ifdef LOCAL
freopen("data.in", "r", stdin);
freopen("data.out", "w", stdout);
#endif
int x, n = 0, min = INF, max = -INF, s = 0;
while(scanf("%d", &x) == 1)
{
s += x;
if(x < min) min = x;
if(x > max) max = x;
/*
printf("x = %d, min = %d, max = %d\n", x, min, max);
*/
n++;
}
printf("%d %d %.3f\n", min, max, (double)s/n);
return 0;
}
```

如果比赛要求用文件输入输出，但禁止用重定向的方式

```c
/**
 * 程序2-11 数据统计（fopen版）
 * 
 * 先声明变量fin和fout（暂且不用考虑FILE*），
 * 把scanf改成fscanf，第一个参数为fin；
 * 把printf改成fprintf，第一个参数为fout，
 * 最后执行fclose，关闭两个文件
 */
#include<stdio.h>
#define INF 1000000000
int main()
{
FILE *fin, *fout;
fin = fopen("data.in", "rb");
fout = fopen("data.out", "wb");
int x, n = 0, min = INF, max = -INF, s = 0;
while(fscanf(fin, "%d", &x) == 1)
{
s += x;
if(x < min) min = x;
if(x > max) max = x;
n++;
}
fprintf(fout, "%d %d %.3f\n", min, max, (double)s/n);
fclose(fin);
fclose(fout);
return 0;
}
```

在算法竞赛中，如果不允许使用重定向方式读写数据，应使用fopen和fscanf/fprintf进行输入输出

在多数据的题目中，一个常见的错误是：在计算完一组数据后某些变量没有重置，影响到下组数据的求解

当嵌套的两个代码块中有同名变量时，内层的变量会屏蔽外层变量，有时会引起十分隐蔽的错误

用编译选项-Wall编译程序时，会给出很多（但不是所有）警告信息,有些“错误”程序是合法的

“伪代码”这一工具，建议“不拘一格”地使用。伪代码是为了让思路更清晰，而不是写“八股文”

在算法竞赛中，常常难以精确计算出需要的数组大小，数组一般会声明得稍大一些。在空间够用的前提下，浪费一点不会有太大影响

比较大的数组应尽量声明在main函数外，否则程序可能无法运行

```c
// 数组不能够进行赋值操作b＝a的。如果要从数组a复制k个元素到数组b，可以这样做
int a[maxn], b[maxn];
memcpy（b, a, sizeof（int）*k）;//string.h
memcpy（b, a, sizeof（a））;

//置零
memset(a, 0, sizeof(a));

```

在很多情况下，最好是在做一件事之前检查是不是可以做，而不要做完再后悔。因为“悔棋”往往比较麻烦

```c
char s[20];
scanf("%s", s);// 读入一个不含空格、TAB和回车符的字符串(没有&)

char buf[100];
//可以用sprintf把信息输出到字符串，用法和printf、fprintf类似。但应当保证字符串足够大(字符个数加1)
sprintf(buf, "%d%d%d%d%d", abc, de, x, y, z);

//strlen(s)返回的就是结束标记之前的字符个数
//strchr的作用是在一个字符串中查找单个字符
if(strchr(s, buf[i]) == NULL)
    return;
```

如果是计算完赋值的右边（即count++）之后就立刻执行，最后count的值不会变（别忘了最后执行的是赋值）；
但如果是整个赋值完成之后才加1，最后count的值会比原来多1

```c
int tot = 0;
printf("%d %d %d",tot++,tot++,tot++);//2 1 0
```

如果在执行函数的过程中碰到了return语句，将直接退出这个函数，不去执行后面的语句。
相反，如果在执行过程中始终没有return语句，则会返回一个不确定的值。
幸好，-Wall可以捕捉到这一可疑情况并产生警告。

在算法竞赛中，请总是让main函数返回0。

调用栈描述的是函数之间的调用关系。它由多个栈帧（Stack Frame）组成，每个栈帧对
应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量，因而不仅能在执行
完毕后找到正确的返回地址，还很自然地保证了不同函数间的局部变量互不相干——因为不
同函数对应着不同的栈帧

```bash
#GDB
g++ <name>.cpp -g       # 编译为可调式
gdb a.exe               # 启动
l(ist)                  # 显示源代码
b(reak) <line number>   # 设断点
b(reak) <fnuction name> # 给函数设断点
cl(ear)                 # 取消断点，和b的格式相同
r(un)                   # 运行 
c(ontinue)              # 继续
n(ext)                  # 单步调试(不进入函数)
s(tep)                  # 单步调试(进入函数)
bt                      # 查看调用栈
p(rint) <parameter>     # 查看变量或表达式值
up                      # 选择上一个栈帧
q(uit)                  # 退出
u(ntil) <line number>   # 让程序执行到指定行
u(ntil) <fnuction name> # 让程序执行到指定函数
disp(lay)               # 把一个表达式设置为display，当程序每次停下来时都会显示其值
i lo(info locals)       # 显示所有局部变量行，u doit就是执行到doit函数的开头位置

# 如果在提示符下直接按Enter键，等价于再次执行上一条指令
# 如果需要连续执行s或者n，只需要第一次输入该命令，然后直接连按Enter键即可。
# 另外，和命令行一样，可以按上下箭头来使用历史记录。

# Shell
size a.exe          # 得到可执行文件中各个段的大小
# PS D:\workspaceFolder\CODE_CPP\PTA> size a.exe
#    text    data     bss     dec     hex filename
#   32128    2832    4992   39952    9c10 a.exe  

# 在可执行文件中:
# 正文段（Text Segment）用于储存指令，
# 数据段（DataSegment）用于储存已初始化的全局变量，
# BSS段（BSS Segment）用于储存未赋值的全局变量所需的空间
# 调用栈并不储存在可执行文件中，而是在运行时创建。
# 调用栈所在的段称为堆栈段（Stack Segment）。
# 和其他段一样，堆栈段也有自己的大小，不能被越界访问，否则就会出现段错误（Segmentation Fault）

# 每次递归调用都需要往调用栈里增加一个栈帧，久而久之就越界了。这种情况叫做栈溢出（Stack Overflow）
```

在运行时，程序会动态创建一个堆栈段，里面存放着调用栈，因此保存着函数的调用关系和局部变量

在Linux中，栈大小并没有储存在可执行程序中，只能用ulimit命令修改；
在Windows中，栈大小储存在可执行程序中，用gcc编译时可以通过-Wl,--stack=[bytecount]指定

什么在建议“把较大的数组放在main函数外”？
别忘了，局部变量也是放在堆栈段的。栈溢出不一定是递归调用太多，也可能是局部变量太大。
只要总大小超过了允许的范围，就会产生栈溢出

程序不是直接从第一行开始写到最后一行结束，而是遵循两种常见的顺序之一：自顶向下和自底向上。
什么叫自顶向下呢？简单地说，就是先写框架，再写细节。实际上，之前已经用过这个方法了，就是先写“伪代码”，然后转化成实际的代码。
有了“函数”这个工具之后，可以更好地贯彻这个方法：先写主程序，包括对函数的调用，再实现函数本身。
自底向上和这个顺序相反，是先写函数，再写主程序。对于编写复杂软件来说，自底向下的构建方式有它独特的优势。但在算法竞赛中并不多见

## C++ STL

C＋＋的cin/cout可以直接读写string类型，却不能读写字符数组

```c
#define ALL(x) x.begin(),x.end()
#define INS(x) inserter(x,x.begin())
```

```c++
// STL的优先队列也定义在头文件<queue>
// 没有迭代器
// 个优先级并不需要一个确定的数字，只需要能比较大小即可
// 可以定义一个结构体cmp，重载“()”运算符
// 定义
priority_queue<int，vector<int>，cmp> pq;
// 越小的整数优先级越大的优先队列可以写成
priority_queue<int，vector<int>，greater<int> > pq;
```

库不一定没有bug，使用之前测试库是一个好习惯

把vector作为参数或者返回值时，应尽量改成用引用方式传递参数，以避免不必要的值被复制

vector、set和map都很快，其中vector的速度接近数组（但仍有差距），
而set和map的速度也远远超过了“用一个vector保存所有值，然后逐个元素进行查找”时的速度。
set和map每次插入、查找和删除时间和元素个数的对数呈线性关系

在一些对时间要求非常高的题目中，STL有时会成为性能瓶颈

如果发现让两个程序答案不一致的数据，最好别急着对它进行调试。可以尝试着减小数
据生成器中的n和m，试图找到一组尽量简单的错误数据。一般来说，数据越简单，越容易
调试。如果发现只有很大的数据才会出错，通常意味着程序在处理极限数据方面有问题，例
如，is_prime中遇到了“过大的n”，或者数组开得不够大等。这些都是很实用的技巧，建议读
者多多积累

：给定一棵包含2
d个结点（其中d为树的高度）的完全二叉树，如果把结点从
上到下从左到右编号为1,2,3……，则结点k的左右子结点编号分别为2k和2k+1
